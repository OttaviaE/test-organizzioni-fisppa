---
title: "Vettori, Matrici e Dataframe"
subtitle: "Test per le organizzaioni"
author: Ottavia M. Epifania, Margherita Calderan
date: ""
format:
  beamer:
    slide-level: 3
    toc-depth: 3
    theme: Montpellier
    monofontoptions: 
    - Scale=0.55
    colortheme: dove
    navigation: horizontal
    highlight-style: tango
    classoption: compress, aspectratio=149
    innertheme: rounded
    outertheme: miniframes
callout-icon: false
code-annotations: below
header-includes: |
  \usepackage{graphicx}
  \usepackage{xcolor}
  \definecolor{ColPrimario}{RGB}{100,8,58}
  \definecolor{ColSecondario}{RGB}{20,143,184}
  \setbeamercolor{structure}{fg=ColPrimario}
  \setbeamercolor{itemize item}{fg=ColPrimario}
  \setbeamercolor{itemize subitem}{fg=ColSecondario}
  \setbeamercolor{palette primary}{bg=ColPrimario,fg=white}
  \setbeamercolor{palette secondary}{bg=ColSecondario,fg=white}
  \setbeamercolor{section in head/foot}{bg=ColPrimario,fg=white}
  \setbeamercolor{subsection in head/foot}{bg=ColSecondario,fg=white}
  \setbeamercolor{separation line}{fg=white}
  \setbeamercolor{upper separation line head}{bg=white}
  \setbeamercolor{middle separation line head}{bg=white}
  \setbeamercolor{lower separation line head}{bg=white}
  \AtBeginSubsection{}
  \AtBeginDocument{\institute[]{Università di Padova} }
  \AtBeginDocument{\author{Ottavia M. Epifania\\\texttt{ottavia.epifania@unipd.it}\\[0.5em]Margherita Calderan\\\texttt{margherita.calderan@unipd.it}}}
  \AtBeginSection[]
          {
             \begin{frame}[plain]
             \tableofcontents[currentsection, hideallsubsections]
              \end{frame}
          }
   \AtBeginSubsection[]
          {
             \begin{frame}[plain]
             \tableofcontents[currentsection,currentsubsection,hideothersubsections]
             \end{frame}
          }
editor_options: 
  chunk_output_type: console
execute: 
  echo: true
---



# Vettori

I vettori sono una struttura dati unidimensionale e sono la più semplice presente in R.

![](img/vettore.png){fig-align="center"}


### Caratteristiche di un vettore

-   **la lunghezza**: il numero di elementi da cui è formato il vettore

-   **la tipologia**: la tipologia di dati da cui è formato il vettore. Un vettore infatti deve esssere formato da **elementi tutti dello stesso tipo**!

### Caratteristiche degli elementi di un vettore

-   **un valore**: il valore dell'elemento che può essere di qualsiasi tipo ad esempio un numero o una serie di caratteri

-   **un indice di posizione**: un numero intero positivo che identifica la sua posizione all'interno del vettore.

![](img/vettore.png){fig-align="center"}

### Creare un vettore

I vettori si possono creare attraverso il comando **`c()`**, indicando tra le parentesi i valori degli elementi nella sucessione desiderata e separati da una virgola.

```{r, echo=TRUE}
num_vect = c(1,2,3,4)
```

::: fragment
```{r,echo=TRUE}
char_vect = c("R","R","R","ok")
```
:::

### Tiplogia di vettore

La tipologia di dati da cui è formato il vettore.

```{r, echo=TRUE}
class(num_vect)
class(char_vect)
```

### Tiplogia di vettore

Un vettore deve esssere formato da **elementi tutti dello stesso tipo**!

```{r, echo=TRUE}
wrong = c(1,2,3,"non so", 4)
class(wrong) 
wrong
```

Altrimenti si "rischia" che tutto venga trasformato a carattere.

::: fragment
```{r, echo=TRUE}
correct = c(1,2,3,NA, 4)
class(correct) 
correct
```
:::

### is.\* & as.\*

Possiamo testare o convertire (quando possibile) la tipologia del vettore attraverso queste funzioni **`is.`** & **`as.`**

::: fragment
Vettore di tipo `character`

```{r, echo = TRUE}
char_vect
is.character(char_vect)
as.numeric(char_vect) #!!
```
:::

### is.\* & as.\*

Vettore di tipo `numeric`

```{r, echo = TRUE}
num_vect
is.numeric(num_vect)
as.character(num_vect) #!!
```


### is.\* & as.\*

Vettore di tipo `logical`

```{r, echo = TRUE}
logi_vect = c(TRUE,FALSE,TRUE)
is.logical(logi_vect)
```

```{r, echo = TRUE, eval=FALSE}
as.numeric(logi_vect)
```

```{r}
as.numeric(logi_vect)
```


## Indicizzazione

Possiamo selezionare, eliminare, estrarre elementi semplicemente usando l'indice di posizione tramite le parentesi quadre vettore \[pos\] .

```{r, echo=TRUE}
# Creo un vettore formato da 10 numeri casuali
my_vect = round(runif(n = 10,min = 1, max = 100))
my_vect
```

::: fragment
```{r, echo=TRUE}
my_vect[1] # estraggo il primo elemento
```
:::

### 

```{r, echo=TRUE}
my_vect[1:5] # estraggo i primi 5 elementi
```

```{r, echo=TRUE}
my_vect[c(1,4,2,9)] # estraggo elementi a scelta
```


### Inidicizzazione Negativa

Allo stesso modo possiamo decidere di estrarre tutti gli elementi del vettore eccetto alcuni

```{r, echo=TRUE}

my_vect[-c(1)] #tutti tranne il primo elemento

my_vect[-c(1:9)] #tutti tranne i primi 10
```


### Indicizzazione Logica

Possiamo selezionare elementi dal vettore basandoci su specifiche condizioni logiche: **`TRUE`** e **`FALSE`**.

```{r, echo=TRUE}
numeri = 1:7; numeri
```

```{r,echo=TRUE}
numeri>2 & numeri<5
```

```{r}
numeri[numeri>2 & numeri<5]
```


### Operazioni matematiche sui vettori

Possiamo eseguire operazioni sui vettori, ed applicare la stessa operazione a tutti gli elementi del vettore (element-wise)

```{r, echo=TRUE}
# ?rep
new_vect = rep(2:4, each = 2)
new_vect

# potete svolgere qualsiasi operazione
new_vect/2
```



# Fattori

I fattori sono una tipologia di dato peculiare e per quanto simile a semplici **`characters`** in realtà sono un tipo di vettore **`integer`** con delle proprietà aggiuntive.

### Creare un fattore: `as.factor`

```{r, echo=TRUE}
char_vect = rep(c("hello","ciao", "hola"), each = 2)
char_vect

my_fact = as.factor(char_vect)
my_fact
```

### Creare un fattore: `factor()`

```{r, echo=TRUE}
my_fact = factor(x = rep(c("hello","ciao", "hola"), each = 2), 
                 levels = c("hello","ciao","hola"),
                   labels = c("hello","ciao","hola"))

my_fact
```

### 

I fattori permettono di avere dei livelli **`levels()`** come metadati,

```{r, echo = TRUE}
levels(my_fact)
```


###

A prescindere da quali siano effettivamente presenti nel vettore. 
Per esempio se creo un fattore composto solo dagli elementi di my_fact diversi da ciao:

```{r, echo = TRUE}
my_fact2 = my_fact[my_fact!="ciao"]
```

I livelli di my_fact2 saranno gli stessi di my_fact ("ciao" incluso) anche se "ciao" non è presente come osservazione:

```{r, echo = TRUE}
my_fact2
levels(my_fact2)
```

### 

E' possibile però eslcudere i livelli non più utili attraverso il comando `droplevels()`:

```{r, echo = TRUE}
# come sarebbe my_fact2?
droplevels(my_fact2) 

# modifico my_fact2 eliminando i livelli inutili
my_fact2 = droplevels(my_fact2) 
my_fact2
```


# Matrici

Le matrici sono una struttura dati **bidimensionale** (caratterizzate da 2 dimensioni **`dim()`** ) dove il numero di righe rappresenta la dimensione 1 e il numero di colonne la dimensione 2.

```{r, echo=TRUE}
my_mat = matrix(data = 1:10, nrow = 2, ncol = 5)
my_mat
```


### Matrici 

```{r, echo=TRUE}
my_mat = matrix(data = 1:10, nrow = 2, 
                ncol = 5)
nrow(my_mat)
ncol(my_mat)
```

### Matrici - Caratteristiche

-   Possono contenere **una sola tipologia** di dati

-   Essendo **bidimensionali**, abbiamo bisogno di due indici di posizione (righe e colonne) per identificare un elemento

-   Possono essere viste come un **insieme** di singoli **vettori**

### Matrici - Caratteristiche

Il numero di righe e colonne non deve essere lo stesso necessariamente (matrice quadrata) ma il numero di righe deve essere compatibile con il vettore data:

```{r, echo=TRUE, warning=TRUE}
matrix(data = 1:10, ncol = 3, nrow = 3)
```

### 

Cosa fa R di default?

```{r, echo=TRUE, warning=FALSE}

matrix(data = 1:10, ncol = 3, nrow = 3)

matrix(data = 1:2, ncol = 3, nrow = 3)

```

**`warnings`**: la funzione ci informa di qualcosa di potenzialmente problematico, ma (circa!!) tutto liscio

## Matrici - Indicizzazione

Per identificare uno o più elementi nella matrice abbiamo bisogno di indici/e di riga e/o colonna separati da virgola, sempre con le parentesi quadre: **matrice\[riga, colonna\]**

```{r, echo=TRUE}

my_mat
my_mat[1,1]

```

###

E' possibile anche selezionare un'intera riga o colonna

```{r, echo=TRUE}

my_mat[1,]

my_mat[,1]

```

### Indicizzazione logica 

```{r, echo=TRUE}
my_mat>2
my_mat
# Tutti gli elementi maggiori di due
my_mat[my_mat>2]
```

### Vettori e Matrici

I vettori si creano attraverso la funzione **`c()`** e possono essere concatenati tra loro sempre attraverso la stessa funzione:

```{r, echo=TRUE}
my_vect1 = c(1:4)
my_vect2 = c(5:10)

my_vect12 = c(my_vect1,my_vect2)
my_vect12
```

###

```{r, echo=TRUE}

my_mat1 = matrix(data = 1:4,nrow = 2, ncol = 2)
my_mat1
my_mat2 = matrix(data = 5:8,nrow = 2, ncol = 2)
my_mat2

```

###

Le matrici possono essere unite tra loro attraverso i comandi:

**`cbind()`**

```{r, echo=TRUE}
cbind(my_mat1, my_mat2)

```

###

**`rowbind()`**

```{r, echo=TRUE}

rbind(my_mat1, my_mat2)

```

Cosa notate di "strano"?

### Operazioni con le matrici

Come per i vettori, anche alle matrici si possono applicare operazioni matematiche:

```{r, echo=TRUE}

my_mat = matrix(data = 1:4,nrow = 2, ncol = 2)

# elemet-wise
my_mat*my_mat

```


### Operazioni con le matrici

Come per i vettori, anche alle matrici si possono applicare operazioni matematiche:

```{r, echo=TRUE}

# Prodotto matriciale
my_mat%*%my_mat
# (1*1 + 3*2) , (1*3 + 3*4)
# (2*1 + 4*2) , (2*3 + 4*4)
```


# Dataframe

Il dataframe è la struttura più "complessa", utile e potente di R. 

-   ogni elemento  è un **vettore** con un **nome associato** (aka una colonna)
-   ogni colonna deve avere lo stesso numero di elementi
-   di conseguenza ogni riga ha lo stesso numero di elementi (**struttura rettangolare**)

## Creazione

Si creano attraverso il comando `data.frame`

```{r, echo=TRUE}
# Creo un dataframe con 3 colonne 
my_df = data.frame( numeri = 1:4, lettere = letters[1:4],
                    normale = rnorm(n = 4, mean = 0, sd = 1)) 
my_df
```

### Attributi

Il **`dataframe`** ha sia gli attributi della lista ovvero i ***names*** ma anche gli attributi della matrice ovvero le ***dimensioni*** (righe e colonne)

```{r, echo=TRUE}
attributes(my_df)
dim(my_df)
```

### 

Possiamo utlizzare le funzioni **`names()`** , **`dim()`**, **`nrow()`**, **`ncol()`**... per ottenere informazioni sulle caratteristiche del dataframe. La funzione più utile è **`str()`** poichè ci restituisce una veloce overview della struttura del dataframe: dimensioni, tipi di variabili,...

```{r,echo=TRUE}
str(my_df) 
```


## Indicizzazione 

```{r, echo = TRUE}
my_df[1]  # estraggo un data.frame 5x1
my_df[[1]] # estraggo la prima colonna del data.frame
my_df[1,1] #  estraggo il primo elemento della prima colonna del data.frame
```

### Indicizzazione `$`

```{r, echo=TRUE}
my_df$numeri # estraggo la prima colonna del data.frame
my_df$numeri[1] #  estraggo il primo elemento della prima colonna del data.frame

```


### Indicizzazione - Operatori relazionali

Una delle operazioni più comuni che dovrete affrontare sarà sicuramente quella di estrarre/valutare un sottoinsieme di valori presenti nel vostro dataset:

```{r, echo=TRUE}
my_df

# includo solo le righe in cui alla colonna1 i valori sono maggiori di 2
my_df[my_df$numeri > 2, ]
my_df[my_df[1] > 2, ] 
```

## Esempi

```{r}
my_df
```

```{r, echo=TRUE,eval=FALSE}
my_df[my_df$numeri > 2 & my_df$numeri < 4, ]
```

```{r, eval=TRUE, echo=FALSE}
my_df[my_df$numeri > 2 & my_df$numeri < 4, ]
```

```{r, echo=TRUE,eval=FALSE}
my_df[my_df$numeri== 2,  2]
```

```{r, eval=TRUE, echo=FALSE}
my_df[my_df$col1== 2,  2]
```

```{r, echo=TRUE,eval=FALSE}
my_df[my_df$col1== 2,  "col2"]
```

```{r, eval=TRUE, echo=FALSE}
my_df[my_df$col1== 2,  "col2"]
```


### Indicizzazione `subset()`

```{r,echo=TRUE}
str(iris)
subset(iris, subset = Species == "setosa" & Petal.Length > 1.7)
```

### 

Equivalente a:

```{r,echo=TRUE}

iris[iris$Species == "setosa" & iris$Petal.Length > 1.7,]

```

### `subset(df, select = ...)`

E' possibile anche selezionare colonne piuttosto che righe attraverso l'argomento ***`select`***:

```{r, echo=TRUE, eval=FALSE}
subset(iris, select = c(Sepal.Length, Species))
```

```{r, echo=TRUE}
#visualizzo le prime due righe attraverso il comando head
head(subset(iris, select = c(Sepal.Length, Species)), n = 3) 
```

### `subset(df, subset = ..., select = ...)`

Possiamo anche combinare le due cose:

```{r,echo=TRUE, eval=FALSE}
subset(iris, subset = Species == "setosa" & Sepal.Length > 4, select = c(Sepal.Length, Species))
```

```{r,echo=TRUE}
head(subset(iris, subset = Species == "setosa" & Sepal.Length > 4, select = c(Sepal.Length, Species)), n = 3)
```


### 

La maggiorparte delle volte vi troverete ad accedere alle variabili tramite l'operatore **`$`**. Questo comando può essere utilizzato anche per creare una nuova variabile...

```{r,echo=TRUE}
# creo una variablie che è la somma di Length e Width
iris$somma = iris$Sepal.Length + iris$Sepal.Width

str(iris)
```

###

Si applicano gli stessi concetti che abbiamo visto per i vettori, potete quindi sia creare che modificare variabili.

```{r, echo=TRUE}
my_df = data.frame(num = 1:4, let = letters[1:4])
my_df

# Modfico la variabile num aggiungendo 1
my_df$num = my_df$num+1

# Creo una terza variabile composta dalla varibile num e let
my_df$both = paste(my_df$num,my_df$let, sep = "_") # ?paste

str(my_df)
```


## Combinare Dataframes

Essendo simili a delle matrici, i dataframe si possono combinare tra loro attraverso le funzioni **`rbind()`**:

```{r,echo=TRUE, error=TRUE}
# primo dataframe
str(my_df)
# creo un secondo dataframe
my_df2 = data.frame(num = 4:7, lett = letters[1:4], 
                    both = paste(4:7,letters[1:4], sep = "_"))

str(my_df2)
```

### 

**Unisco i due dataframes**

-   I dataframes devono avere lo stesso numero di colonne

-   I nomi delle colonne devono essere identici

```{r,echo=TRUE, error=TRUE}
my_df3 = rbind(my_df,my_df2) 

str(my_df)
str(my_df2)
```

###

**Sistemo i nomi**

```{r,echo=TRUE, error=TRUE}
names(my_df2)
names(my_df)

# voglio che i names di my_df2 corrispondano ai names di my_df
names(my_df2) = names(my_df)

my_df3 = rbind(my_df,my_df2) 
str(my_df3)
```

###

Potrebbe anche capitarvi di dover raccogliere differenti tipi di dato dallo stesso partecipante, e successivamente combinare le informazioni raccolte...

###

```{r, echo=TRUE}
df_rt = data.frame(subj = factor(rep(c("caio","tizio"),each = 400)),
                   cond = factor(rep(c("easy","hard"), 
                                     each = 200, times = 2)),
                      rt = c(rlnorm(n = 400, meanlog = -1, sdlog = .25), 
                             rlnorm(n = 400, meanlog = -.7, sdlog =.3)))

```

###

Dataframe contente l'età:

```{r, echo=TRUE}
df_age = data.frame(subj = factor(c("caio","tizio")), age = c(20,3))

```

###

```{r,echo=TRUE}
str(df_rt) # struttura dataframe tempi di reazione
head(df_rt)

str(df_age) # struttura dataframe età
head(df_age)
```

###

In questo caso, è possibile utilizzare la funzione **`merge()`**:
```{r, echo=TRUE}
df_all_1 = merge(x = df_rt, y = df_age, by="subj")
str(df_all_1)
```

###

la funzione **`_join()`**:

```{r, echo=TRUE, message=FALSE}
library(dplyr) # carico il pacchetto dplyr

df_all_2 = left_join(x = df_rt, y = df_age, by = c("subj")) # esistono anche right_join; full_join 
str(df_all_2)
```


## Esportazione e importazione dati

In R è possibile importare dati in molti formati differenti, più comunemente vi troverete ad importare dati ***.csv*** oppure ***.xlsx***.

Qui per esempio, esporto i dataframe in tre formati differenti...

```{r, echo=TRUE,message=FALSE,warning=FALSE}
library(readr) # carico il pacchetto readr
library(writexl) # carico il pacchetto writexl

write.csv(df_rt, file = "data/df_rt.csv",row.names = FALSE)
write_xlsx(df_age, path = "data/df_age.xlsx")
save(df_age, file = "data/df_age.rda") # formato R
```

### Importo

```{r, echo=TRUE, eval=FALSE}
library(readxl) # carico il pacchetto readxl

df_rt_impo = read_csv("data/df_rt.csv") #utilizza il pacchetto readr
df_age_impo = read_xlsx("dat/df_age.xlsx")
load(file ="data/df_age.rda") # formato R
```

```{r, echo=FALSE, eval=TRUE}
df_rt_impo = read_csv("data/df_rt.csv") 
```


### Controllo la struttura ed il tipo di dati


```{r,echo=TRUE,message=FALSE}
str(df_rt_impo)
df_rt_impo$subj = as.factor(df_rt_impo$subj)
df_rt_impo$cond = as.factor(df_rt_impo$cond)
str(df_rt_impo)
```




## Ora però facciamo un po' di pratica! {style="text-align: center;"}

<br/> Aprite e tenete aperto questo link:

<https://etherpad.wikimedia.org/p/arca-corsoR>
